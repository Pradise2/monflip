// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title monflip
 * @dev A provably fair coin flip game on the Monad blockchain.
 * This contract implements a commit-reveal scheme for fair randomness
 * and manages all game state and payouts on-chain.
 */
contract monflip {
    // --- State Variables ---

    address public owner;
    bool public paused;
    uint256 public gameCounter;

    uint256 public constant MAX_ROUNDS = 15;
    // Multiplier is represented as a percentage, e.g., 150 = 1.5x
    uint256 public constant MULTIPLIER_PER_WIN_PERCENT = 150;

    struct GameSession {
        address player;
        uint256 betAmount;
        bytes32 clientSeedHash;
        uint256 currentRound;
        uint256 consecutiveWins;
        bool active; // True if the game is in progress
    }

    mapping(uint256 => GameSession) public games;
    mapping(address => uint256) public activeGames; // Player -> Active Game ID

    // --- Events ---

    event GameStarted(uint256 indexed gameId, address indexed player, uint256 betAmount, bytes32 clientSeedHash);
    event FlipResult(uint256 indexed gameId, uint256 round, bool choiceWasHeads, bool outcomeWasHeads, bool won, uint256 consecutiveWins);
    event GameCashedOut(uint256 indexed gameId, address indexed player, uint256 payout);
    event GameLost(uint256 indexed gameId, address indexed player);
    event ContractPaused();
    event ContractResumed();
    event Funded(uint256 amount);
    event Withdrawn(uint256 amount);


    // --- Modifiers ---

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    modifier notPaused() {
        require(!paused, "Game paused");
        _;
    }

    modifier onlyActiveGame(uint256 _gameId) {
        require(games[_gameId].active, "Game is not active");
        require(msg.sender == games[_gameId].player, "Not your game");
        _;
    }

    // --- Constructor ---

    constructor() {
        owner = msg.sender;
    }

    // --- Core Game Logic ---

    /**
     * @notice Starts a new game session. Commits to a client seed hash.
     * @param _clientSeedHash A keccak256 hash of a secret string generated by the client.
     */
    function startGame(bytes32 _clientSeedHash) external payable notPaused {
        require(msg.value > 0, "Bet amount cannot be zero");
        require(activeGames[msg.sender] == 0, "Player already has an active game");

        gameCounter++;
        uint256 newGameId = gameCounter;

        games[newGameId] = GameSession({
            player: msg.sender,
            betAmount: msg.value,
            clientSeedHash: _clientSeedHash,
            currentRound: 0,
            consecutiveWins: 0,
            active: true
        });
        activeGames[msg.sender] = newGameId;

        emit GameStarted(newGameId, msg.sender, msg.value, _clientSeedHash);
    }

    /**
     * @notice Makes a flip for an active game.
     * @param _gameId The ID of the game to make a flip in.
     * @param _clientSeed The secret seed that was hashed in startGame.
     * @param _choiceHeads The player's choice: true for heads, false for tails.
     */
    function makeFlip(uint256 _gameId, string calldata _clientSeed, bool _choiceHeads) external notPaused onlyActiveGame(_gameId) {
        GameSession storage game = games[_gameId];
        require(keccak256(abi.encodePacked(_clientSeed)) == game.clientSeedHash, "Invalid client seed");
        require(game.currentRound < MAX_ROUNDS, "Max rounds reached");

        // --- Randomness Generation (Reveal Phase) ---
        bytes32 serverSeed = keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp, msg.sender));
        bytes32 combinedHash = keccak256(abi.encodePacked(_clientSeed, serverSeed, game.currentRound));
        bool outcomeIsHeads = uint256(combinedHash) % 2 == 0;

        game.currentRound++;
        bool playerWon = (_choiceHeads == outcomeIsHeads);

        if (playerWon) {
            game.consecutiveWins++;
            emit FlipResult(_gameId, game.currentRound, _choiceHeads, outcomeIsHeads, true, game.consecutiveWins);
        } else {
            game.active = false;
            activeGames[game.player] = 0; // Clear active game
            emit FlipResult(_gameId, game.currentRound, _choiceHeads, outcomeIsHeads, false, 0);
            emit GameLost(_gameId, game.player);
        }
    }

    /**
     * @notice Cashes out the winnings for an active game.
     * @param _gameId The ID of the game to cash out.
     * @param _clientSeed The secret seed to prove ownership and finalize randomness.
     */
    function cashOut(uint256 _gameId, string calldata _clientSeed) external notPaused onlyActiveGame(_gameId) {
        GameSession storage game = games[_gameId];
        require(keccak256(abi.encodePacked(_clientSeed)) == game.clientSeedHash, "Invalid client seed");
        require(game.consecutiveWins > 0, "No wins to cash out");

        uint256 payout = calculateWinnings(game.betAmount, game.consecutiveWins);
        game.active = false;
        activeGames[game.player] = 0; // Clear active game

        (bool success, ) = payable(game.player).call{value: payout}("");
        require(success, "Transfer failed");
        emit GameCashedOut(_gameId, game.player, payout);
    }

    // --- View Functions ---

    /**
     * @notice Calculates the winnings based on consecutive wins.
     * @return The total payout amount.
     */
    function calculateWinnings(uint256 _betAmount, uint256 _consecutiveWins) public pure returns (uint256) {
        if (_consecutiveWins == 0) return _betAmount;

        uint256 finalMultiplierPercent = 100; // Starts at 1x
        for (uint i = 0; i < _consecutiveWins; i++) {
            finalMultiplierPercent = (finalMultiplierPercent * MULTIPLIER_PER_WIN_PERCENT) / 100;
        }

        return (_betAmount * finalMultiplierPercent) / 100;
    }

    /**
     * @notice Gets the current potential payout for an active game.
     */
    function getPotentialWin(uint256 _gameId) external view returns (uint256) {
        GameSession storage game = games[_gameId];
        require(game.active, "Game is not active");
        return calculateWinnings(game.betAmount, game.consecutiveWins);
    }

    // --- Admin Functions ---

    function pauseContract() external onlyOwner {
        paused = true;
        emit ContractPaused();
    }

    function resumeContract() external onlyOwner {
        paused = false;
        emit ContractResumed();
    }

    function withdraw(uint256 amount) external onlyOwner {
        require(amount <= address(this).balance, "Insufficient balance");
        (bool success, ) = owner.call{value: amount}("");
        require(success, "Transfer failed");
        emit Withdrawn(amount);
    }

    receive() external payable {
        emit Funded(msg.value);
    }
}
